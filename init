#!/bin/sh
# Tiny init.
# See COPYING and COPYRIGHT files for corresponding information.

# Intentional: "var is referenced but not assigned".
# https://www.shellcheck.net/wiki/SC2154
# shellcheck disable=SC2154

# Intentional: allow "local"s declaration.
# https://www.shellcheck.net/wiki/SC3043
# shellcheck disable=SC3043

export PATH=/bin TERM=linux SHELL=/bin/sh LANG=C LC_ALL=C PS1="# " \
       HOME=/root

######################################################################
# Notification helpers.                                              #
######################################################################

# Print info message to stdout.
#   arg $1: message
info() {
	echo "=======> $1"
}

# Print error message to stderr and terminate the program.
#   arg $1: message
error() {
	echo "=======> ERROR: $1" 1>&2

	exit 1
}

# Print error message to stderr and fallback to the sh(1).
#   arg $1: message
panic() {
	echo "=======> ERROR: ${1:-Unexpected error occurred}" 1>&2

	sh
}

######################################################################
# Init helpers.                                                      #
######################################################################

# Set ''device'' variable to full path of resolved UUID, PARTUUID,
# LABEL, or /dev/*.
#   arg $1: device
resolve_device() {
	device="$1"
	local _COUNT="${2:-30}"

	case "${device%%=*}" in
	    UUID) device="/dev/disk/by-uuid/${device#*=}"     ;;
	   LABEL) device="/dev/disk/by-label/${device#*=}"    ;;
	PARTUUID) device="/dev/disk/by-partuuid/${device#*=}" ;;
	  /dev/*)                                             ;;
	       *) return 0                                    ;;
  	esac

	# Race condition may occur if device manager is not yet
	# initialized device.  To fix this, we simply waiting until
	# device is available.  If device didn't appear in specified
	# time, we panic.
	while : ; do
		if [ -b "$device" ]; then
			return 0
		elif [ "$((_COUNT -= 1))" = 0 ]; then
			break
		else
			sleep 1
		fi
	done

	panic "Failed to lookup partition: $device"
}

# Run hooks (by type) if any exist.
#   arg $1: hook type (init or init.late)
run_hook() {
	local _HOOK
	local _HOOKTYPE="$1"

	# Intentional: "can't follow non-constant source".
	# https://www.shellcheck.net/wiki/SC1090
	# shellcheck disable=SC1090
	for _HOOK in $hooks; do
		if [ -f "/usr/share/mkinitramfs/hooks/$_HOOK/$_HOOK.$_HOOKTYPE" ]; then
			. "/usr/share/mkinitramfs/hooks/$_HOOK/$_HOOK.$_HOOKTYPE"
		fi
	done
}

# Mount base filesystems, like /proc, /sys, /run and /dev.
mount_basefs() {
	mount -t proc     -o nosuid,noexec,nodev     proc /proc
	mount -t sysfs    -o nosuid,noexec,nodev     sys  /sys
	mount -t tmpfs    -o nosuid,nodev,mode=0755  run  /run
	mount -t devtmpfs -o nosuid,noexec,mode=0755 dev  /dev

	# HACK! Some scripts needs this.
	ln -s /proc/self/fd /dev/fd
	ln -s fd/0          /dev/stdin
	ln -s fd/1          /dev/stdout
	ln -s fd/2          /dev/stderr
}

# Read kernel command-line arguments.
parse_cmdline() {
	local _CMDLINE
	local _PARAM

	read -r _CMDLINE < /proc/cmdline

	# https://kernel.org/doc/html/latest/admin-guide/kernel-parameters.html
	# ... parameters with '=' go into init's environment ...
	for _PARAM in $_CMDLINE; do
		case "$_PARAM" in
		rootfstype=*) root_type="${_PARAM#*=}"            ;;
		 rootflags=*) root_opts="${_PARAM#*=}"            ;;
		 rootdelay=*) root_wait="${_PARAM#*=}"            ;;
		    rootwait) root_wait=-1                        ;;
		     debug=1) set -x                              ;;
		       ro|rw) rorw="$_PARAM"                      ;;
		      init=*) init="${_PARAM#*=}"                 ;;
		         --*) init_args="${_PARAM##*-- }" ; break ;;
		         *=*) command export "$_PARAM"            ;;
		           *) command export "$_PARAM=1"          ;;
		esac 2>/dev/null || :
	done
}

# Mount root filesystem.
mount_root() {
  if [ "$break" = root ]; then
	  info "break before mount_root()"

	  sh
  fi

  resolve_device "$root" "${root_wait:-$rootdelay}"

  # Intentional word splitting.
  # https://www.shellcheck.net/wiki/SC2086
  # shellcheck disable=SC2086
  mount \
    -o "${rorw:-ro}${root_opts:+,$root_opts}"  \
    ${root_type:+-t $root_type} \
    -- "$device" /mnt/root || panic "Failed to mount rootfs: $device"
}

# Switch to mounted root filesystem as the root of the mount tree and
# start init process.
boot_system() {
	local _DIR

	if [ "$break" = boot ]; then
		info "break before boot_system()"

		sh
	fi

	# XXX seems like switch_root(8) already doing this
	for _DIR in run dev sys proc; do
		mount -o move "/$_DIR" "/mnt/root/$_DIR" || :
	done

	# POSIX 'exec' has no '-c' flag to execute command with empty
	# environment.  Using 'env -i' instead to prevent leaking
	# exported variables.
	#
	# Some implementations of 'switch_root' doesn't conform to
	# POSIX utility guidelines and doesn't support '--'.  This
	# means that safety of init_args isn't guaranteed.

	# Intentional word splitting.
	# https://www.shellcheck.net/wiki/SC2086
	# shellcheck disable=SC2086
	exec env -i TERM=linux PATH=/bin:/sbin:/usr/bin:/usr/sbin \
		switch_root /mnt/root \
		"${init-/sbin/init}" $init_args ||
			panic "Failed to boot system"
}

######################################################################

# -e: Exit if command return status greater than 0.
# -f: Disable globbing *?[].
set -ef

# Run emergency shell if init unexpectedly exiting due to error.
trap panic EXIT

# Read configuration.
# https://www.shellcheck.net/wiki/SC1091
# shellcheck disable=SC1091
. /etc/mkinitramfs/config

# Run init helpers.
mount_basefs
parse_cmdline
run_hook init
mount_root
run_hook init.late
boot_system

# vim: cc=72 tw=70
# End of file.
